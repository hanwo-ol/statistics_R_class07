## 수업 중 질문 1 : 영어 ~ 한글 변환
<details> 
<summary> 답변 펼치기 </summary>

답변 예정입니다.

</details>


## 수업 중 질문 2: 그림 및 표 저장 시, 크기를 지정해서 저장하는 방법?

<details>
<summary>답변 펼치기</summary>

로컬에 플롯을 특정 픽셀 크기로 저장하는 방법은 사용하는 그래픽 시스템에 따라 다릅니다. R의 기본 그래픽 함수를 사용하는 경우와 `ggplot2` 패키지를 사용하는 경우, 각각 다른 함수와 인자를 사용해야 합니다.

### ggplot2를 사용하는 경우

`ggplot2`로 생성한 플롯은 **`ggsave()`** 함수를 사용하여 저장하는 것이 가장 편리하고 일반적입니다. 이 함수는 현재 작업 디렉토리에 있는 마지막 ggplot 객체를 저장하거나, 저장할 객체를 직접 지정할 수 있습니다. 픽셀 크기를 지정하려면 `width`, `height`, `dpi`, `units` 인자를 활용합니다.

`ggsave()` 함수의 주요 인자는 다음과 같습니다.

  * `filename`: 저장할 파일의 이름과 확장자 (예: "plot.png", "plot.jpeg")
  * `plot`: 저장할 ggplot 객체 (지정하지 않으면 마지막으로 생성된 플롯이 저장됨)
  * `width`, `height`: 플롯의 너비와 높이
  * `units`: `width`와 `height`의 단위. "px"(픽셀), "in"(인치), "cm", "mm" 등을 지정할 수 있습니다.
  * `dpi`: 해상도 (Dots Per Inch). 픽셀 단위로 저장할 때 `dpi`는 `width`와 `height`가 픽셀 단위로 직접 해석되도록 도와줍니다.

**픽셀(pixel) 단위로 크기를 지정하여 저장하는 방법**은 두 가지가 있습니다.

1.  **`units = "px"`로 직접 지정하기**
    가장 직관적인 방법입니다. `width`와 `height`를 원하는 픽셀 값으로 설정하고 `units`를 `"px"`로 지정합니다.

    ```r
    # 예제 ggplot 객체 생성
    library(ggplot2)
    buy <- utils::read.csv("D:/2025여름 특강/R/B_data/buy.csv")

    p <- ggplot(buy, aes(x = co, y = prod)) +
      geom_point(alpha = 0.5) +
      geom_smooth(method = "lm", col = "blue", se = FALSE) +
      labs(title = "기업호감도와 제품호감도의 관계",
           x = "기업호감도 (co)",
           y = "제품호감도 (prod)")

    # 1920x1080 픽셀 크기로 저장
    ggsave("plot_1920x1080.png", plot = p, width = 1920, height = 1080, units = "px")
    ```

2.  **인치(inch)와 DPI를 조합하여 사용하기**
    때로는 인치 단위로 크기를 정하고 해상도(DPI)를 통해 최종 픽셀 크기를 조절하는 것이 유용할 수 있습니다. 최종 픽셀 크기는 `(너비 인치 × DPI) × (높이 인치 × DPI)`가 됩니다. 예를 들어, 너비 10인치, 높이 6인치 플롯을 300 DPI로 저장하면 `(10 × 300) × (6 × 300)` = `3000 × 1800` 픽셀이 됩니다.

    ```r
    # 너비 10인치, 높이 6인치, 300 DPI로 저장 (결과: 3000x1800 픽셀)
    ggsave("plot_3000x1800_dpi.png", plot = p, width = 10, height = 6, dpi = 300, units = "in")
    ```

-----

### 기본 그래픽(Base R)을 사용하는 경우

`ggplot2`를 사용하지 않고 `plot()`, `hist()`, `boxplot()`과 같은 R 기본 그래픽 함수로 그린 플롯을 저장할 때는 그래픽 장치(graphics device)를 직접 열고, 플롯을 그린 후, 장치를 닫는 방식을 사용합니다.

대표적으로 사용되는 함수는 `png()`, `jpeg()`, `tiff()`, `bmp()` 등이 있으며, 모두 `width`와 `height`, 그리고 `units` 인자를 지원합니다.

**저장 과정**은 다음과 같습니다.

1.  `png()` 또는 원하는 다른 형식의 함수를 호출하여 파일 이름과 픽셀 크기를 지정합니다. 이때 `units = "px"`로 설정합니다.
2.  `plot()` 등 기본 그래픽 함수를 사용하여 플롯을 그립니다.
3.  **`dev.off()`** 함수를 호출하여 그래픽 장치를 닫고 파일 저장을 완료합니다. **이 과정을 생략하면 파일이 제대로 저장되지 않으므로 매우 중요합니다.**

<!-- end list -->

```r
# 가상의 데이터 생성
x <- 1:100
y <- x + rnorm(100, mean = 0, sd = 10)

# 1. png 그래픽 장치를 열고 800x600 픽셀로 설정
png("base_plot_800x600.png", width = 800, height = 600, units = "px")

# 2. 기본 plot 함수로 산점도 그리기
plot(x, y, main = "기본 플롯 예제", xlab = "X축", ylab = "Y축", pch = 19, col = "steelblue")
# 추세선 추가
abline(lm(y ~ x), col = "red", lwd = 2)

# 3. 그래픽 장치를 닫아 파일 저장 완료
dev.off()
```

이와 같이 `jpeg()` 함수를 사용하면 JPEG 파일로, `tiff()` 함수를 사용하면 TIFF 파일로 동일한 방식으로 저장할 수 있습니다.

</details>


## 수업 중 질문 3 : 그림 및 표 저장 후, 컴퓨터에서 편집하는 방법이 있나?
<details>
<summary>답변 펼치기</summary>

결론부터 말하면, **PNG나 JPEG 같은 이미지 파일(.png, .jpg)로 저장된 플롯은 다시 R로 불러와서 수정할 수 없습니다.** 이미지 파일은 플롯의 '그림'만 저장할 뿐, 플롯을 구성하는 데이터나 각 요소(축, 제목, 색상 등)에 대한 정보를 담고 있지 않기 때문입니다.

하지만 **플롯 객체(object) 자체를 저장**하면 나중에 얼마든지 불러와서 수정할 수 있습니다. 이는 그림의 스케치나 설계도를 저장하는 것과 비슷합니다.

-----

### ggplot2 플롯을 저장하고 수정하는 방법

`ggplot2`로 만든 플롯은 그 자체가 R의 '객체(object)'입니다. 이 객체를 파일로 저장했다가 나중에 다시 불러와서 다른 요소를 추가하거나 기존 요소를 변경할 수 있습니다.

**`saveRDS()`** 함수로 ggplot 객체를 저장하고, **`readRDS()`** 함수로 다시 불러옵니다.

#### **1. ggplot 객체 생성 및 저장**

먼저, 수정하고 싶은 ggplot 플롯을 변수에 할당한 뒤 `saveRDS()`를 이용해 `.rds` 파일로 저장합니다.

```r
library(ggplot2)

# 예제 ggplot 객체 생성
my_plot <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_point() +
  labs(title = "붓꽃 데이터 산점도",
       subtitle = "초기 버전")

# ggplot 객체를 'my_plot.rds' 파일로 저장
saveRDS(my_plot, "my_plot.rds")
```

#### **2. 저장된 ggplot 객체 불러와서 수정하기**

이제 R을 새로 시작했거나 다른 작업을 하다가, 아까 저장해둔 플롯을 수정하고 싶다고 가정해 봅시다. `readRDS()`로 객체를 불러온 후, `+` 기호를 사용해 새로운 레이어나 테마를 추가하여 수정할 수 있습니다.

```r
# 저장했던 ggplot 객체를 새로운 변수로 불러오기
reloaded_plot <- readRDS("my_plot.rds")

# 불러온 플롯에 새로운 요소 추가하여 수정
modified_plot <- reloaded_plot +
  geom_smooth(method = "lm", col = "red") +  # 회귀선 추가
  theme_bw() +                               # 테마 변경
  labs(title = "붓꽃 데이터 산점도 (수정본)",  # 제목 수정
       subtitle = "회귀선과 새로운 테마 적용")

# 수정된 최종 플롯 출력
print(modified_plot)
```



이렇게 하면 기존 플롯을 처음부터 다시 코딩할 필요 없이, 저장된 객체를 기반으로 손쉽게 제목을 바꾸거나, 색상을 변경하거나, 새로운 통계 분석 결과를 덧붙이는 등 다양한 수정을 할 수 있습니다.

-----

### \#\# Base R 플롯을 저장하고 수정하는 방법

Base R의 `plot()` 함수 등은 `ggplot2`처럼 플롯을 객체로 바로 반환하지 않아 조금 다른 접근이 필요합니다. `recordPlot()` 함수를 사용하면 현재 그래픽 장치에 그려진 Base R 플롯을 저장 가능한 객체로 만들 수 있습니다.

#### **1. Base R 플롯 기록 및 저장**

```r
# Base R로 플롯 그리기
plot(mtcars$wt, mtcars$mpg,
     xlab = "차량 무게", ylab = "연비(MPG)",
     main = "차량 무게와 연비의 관계")

# 현재 플롯을 객체로 기록
base_plot_record <- recordPlot()

# 기록된 플롯 객체를 파일로 저장
saveRDS(base_plot_record, "base_plot.rds")
```

#### **2. 저장된 Base R 플롯 불러와서 출력하기**

`readRDS()`로 객체를 불러온 뒤, `replayPlot()` 함수를 사용해 플롯을 다시 그릴 수 있습니다.

```r
# 저장했던 Base R 플롯 기록을 불러오기
reloaded_base_plot <- readRDS("base_plot.rds")

# 플롯을 다시 그리기
replayPlot(reloaded_base_plot)

# 여기에 추가적인 요소를 더할 수 있음
title(sub = "Base R 플롯 다시 그리기", col.sub = "blue")
points(x = 4, y = 25, col = "red", pch = 17, cex = 2) # 새로운 점 추가
```

**주의할 점:** Base R 플롯은 `ggplot2`처럼 레이어(layer)를 더하는 방식으로 수정하기는 어렵습니다. `replayPlot()`으로 기존 플롯을 다시 그린 후, 그 위에 `points()`, `lines()`, `text()`, `title()` 같은 저수준(low-level) 함수를 이용해 요소를 덧그리는 방식으로 수정해야 합니다.

### **요약**

| 구분 | **수정 가능 여부** | **방법** |
| :--- | :--- | :--- |
| **이미지 파일 (.png, .jpg 등)** | **불가능** ❌ | - |
| **ggplot2 객체** | **가능** ✅ | `saveRDS()`로 객체를 저장하고, `readRDS()`로 불러와 `+`로 수정 |
| **Base R 플롯** | **제한적 가능** ✅ | `recordPlot()`으로 기록/저장 후, `replayPlot()`으로 다시 그리고 요소 덧그리기 |

</details>

## 예상되는 질문 1 : rds파일에는 어떤 정보가 담기는 건데?

<details>
<summary> 답변 펼치기 </summary>

`.rds` 파일은 R의 객체를 **그 모습 그대로** 저장하는 파일 형식입니다. 단순히 '그림'만 저장하는 이미지 파일과 달리, `.rds` 파일에는 플롯을 만드는 데 사용된 **모든 정보**가 담겨 있습니다.

`ggplot2` 플롯 객체를 `.rds` 파일로 저장했다면, 그 안에는 다음과 같은 정보들이 포함됩니다.

### ## 1. 데이터 (Data)

플롯을 그리는 데 사용된 **원본 데이터**가 그대로 저장됩니다. 예를 들어 `ggplot(iris, ...)`로 플롯을 만들었다면, `iris` 데이터 프레임의 모든 정보가 플롯 객체 안에 포함됩니다.

### ## 2. 매핑 정보 (Aesthetic Mappings)

`aes()` 함수 안에 지정한 **매핑 규칙**이 저장됩니다.
* 어떤 변수를 x축에 매핑했는지 (`aes(x = Sepal.Length)`)
* 어떤 변수를 y축에 매핑했는지 (`aes(y = Sepal.Width)`)
* 어떤 변수를 색상, 모양, 크기 등으로 구분했는지 (`aes(color = Species)`)

### ## 3. 레이어 (Layers) 겹겹의 그림

`+` 기호로 추가한 **모든 레이어 정보**가 각각 저장됩니다.
* **`geom_point()`**: 점을 찍는 레이어와 그에 대한 설정(색상, 크기, 투명도 등)
* **`geom_smooth()`**: 추세선을 그리는 레이어와 그에 대한 설정(선 종류, 색상, 신뢰구간 표시 여부 등)
* **`geom_bar()`, `geom_histogram()`** 등 사용한 모든 `geom` 함수 정보

### ## 4. 축, 범례, 테마 등 기타 설정

플롯의 시각적 요소를 꾸미기 위해 추가한 **모든 설정 정보**가 담겨 있습니다.
* **`labs()`**: 제목, 부제, 축 이름, 범례 제목 등 텍스트 정보
* **`theme()`**: 글자 크기, 배경색, 격자선 등 플롯의 전반적인 디자인 테마 정보
* **`scale_*()`**: 축의 범위, 눈금, 색상 팔레트 등 스케일 조정 정보
* **`facet_wrap()` / `facet_grid()`**: 플롯을 여러 개로 나누는 패싯(facet) 정보

---

### 음... ** 비유하자면...**

* **`.png` 파일**은 잘 차려진 **완성된 요리 사진** 입니다. 보기에는 좋지만, 어떤 재료가 얼마나 들어갔는지, 레시피는 어땠는지 알 수 없습니다.
* **`.rds` 파일**은 요리의 **상세한 레시피와 모든 재료가 담긴 밀키트(meal kit)**  와 같습니다. 레시피(코드)와 재료(데이터)가 모두 들어있어, 언제든지 똑같은 요리를 다시 만들 수도 있고, 원한다면 새로운 재료를 추가하거나(레이어 추가) 양념을 바꿔서(테마 변경) 다른 버전의 요리를 만들 수도 있습니다.

따라서 `.rds` 파일은 단순한 결과물이 아니라, **수정과 재사용이 가능한 R 객체**를 저장하는 강력한 방법입니다.

</details>

## 예상되는 질문 2 : rds 파일 저장 후 불러오면 이전에 사용된 코드를 복원할 수 있을까?

<details>
<summary> 답변 펼치기 </summary>
.rds 파일에서 객체를 생성하는 데 사용된 원본 소스 코드를 복원하는 것은 불가능합니다.

.rds 파일은 코드의 **실행 결과물인 R 객체 자체**를 직렬화(serialize)하여 저장하는 것이지, 코드를 텍스트 형태로 저장하는 것이 아니기 때문입니다.

-----

### .rds 파일 불러오기와 사용법

.rds 파일을 불러와서 사용하는 정확한 절차는 다음과 같습니다.

#### **1. .rds 파일 불러오기**

`readRDS()` 함수를 사용하여 파일에 저장된 R 객체를 현재 작업 환경(environment)으로 불러옵니다.

```r
# 'my_plot.rds' 파일에 저장된 ggplot 객체를 'loaded_plot'이라는 변수로 불러오기
loaded_plot <- readRDS("my_plot.rds")
```

#### **2. 불러온 객체의 구조 확인**

코드를 볼 수는 없지만, 객체의 구조와 내용을 확인하여 어떻게 구성되었는지 파악할 수 있습니다.

  * **`print()` 함수**: `ggplot` 객체의 경우, `print(loaded_plot)`를 실행하면 어떤 데이터, 매핑, 레이어가 사용되었는지 요약된 정보를 보여줍니다.
  * **`str()` 함수 (Structure)**: `str(loaded_plot)`를 실행하면 객체의 내부 구조를 자세히 보여줍니다. 데이터, 레이어, 스케일, 테마 등 모든 구성 요소가 어떤 계층 구조로 저장되어 있는지 확인할 수 있습니다.
  * **`summary()` 함수**: `summary(loaded_plot)`를 통해 객체의 주요 정보를 요약해서 볼 수 있습니다.

<!-- end list -->

```r
# 불러온 ggplot 객체의 요약 정보 출력
print(loaded_plot)

# 불러온 객체의 상세 구조 확인
# 출력이 매우 길고 복잡할 수 있습니다.
str(loaded_plot)
```

#### **3. 불러온 객체 수정 및 활용**

불러온 객체는 완전히 작동하는 R 객체이므로, 여기에 새로운 레이어나 설정을 추가하여 수정할 수 있습니다.

```r
# 불러온 loaded_plot 객체에 새로운 제목을 추가하고 테마를 변경
modified_plot <- loaded_plot +
  labs(title = "새로운 제목", subtitle = "객체 불러오기 후 수정됨") +
  theme_classic()

# 수정된 플롯을 화면에 출력
print(modified_plot)
```

-----

### 올바른 작업 방식: 스크립트와 객체 파일의 병행 관리

코드 복원이 불가능하기 때문에, 재현성과 유지보수를 위한 최상의 방법은 **코드가 담긴 R 스크립트(`.R` 파일)와 결과물인 객체(`.rds` 파일)를 함께 저장하고 관리**하는 것입니다.

1.  **R 스크립트(.R) 작성**: 플롯을 생성하는 모든 `ggplot` 코드를 스크립트 파일에 작성하고 저장합니다. 이 파일이 플롯을 만드는 원본 설계도 역할을 합니다.
2.  **객체 생성 및 .rds 저장**: 스크립트를 실행하여 생성된 플롯 객체를 `saveRDS()`를 이용해 `.rds` 파일로 저장합니다. 이는 시간이 오래 걸리는 계산 결과를 다시 실행할 필요 없이 빠르게 불러오기 위한 목적입니다.

| 구분 | R 스크립트 (`.R` 파일) | RDS 파일 (`.rds` 파일) |
| :--- | :--- | :--- |
| **역할** | 객체를 생성하는 **명령어(코드) 모음** | 코드가 실행된 후의 **결과물(객체) 저장** |
| **내용물** | `library()`, `ggplot()`, `geom_*()` 등 텍스트로 된 코드 | 데이터, 매핑, 레이어, 스케일 등의 구조를 가진 R 객체 |
| **주요 용도** | 코드의 수정, 재사용, 공유, 재현 | 생성된 객체의 빠른 불러오기, 다른 스크립트에서 활용 |

</summary>
